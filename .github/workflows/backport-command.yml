name: backport-command
on:
  repository_dispatch:
    types: [backport-command]
jobs:
  # outputs the source of the comment (PR or issue)
  backport-type:
    outputs:
      commented_on: ${{ steps.type.outputs.commented_on }}
    runs-on: ubuntu-latest
    env:
      TARGET_ORG: ${{ github.event.client_payload.slash_command.args.named.org }}
      TARGET_REPO: ${{ github.event.client_payload.slash_command.args.named.repo }}
    steps:
      - name: Debug
        env:
          GH_CONTEXT: ${{ toJson(github) }}
        run: |
          set -x
          echo $GH_CONTEXT

      - name: Get type of backport (issue or PR)
        env:
          GITHUB_TOKEN: ${{ secrets.ACTIONS_BOT_TOKEN }}
          ARG1: ${{ github.event.client_payload.slash_command.args.unnamed.arg1 }}
          CLIENT_PAYLOAD: ${{ toJson(github.event.client_payload) }}
        id: type
        run: |
          branches=$(gh api "/repos/${TARGET_ORG}/${TARGET_REPO}/branches" --jq '.[] | select(.name=='\"$ARG1\"')')
          if [[ $branches == "" ]]; then
            echo "Branch name not found"
            exit 1
          fi
          if [[ $(echo $CLIENT_PAYLOAD | jq 'has("pull_request")') == true ]]; then
            commented_on=pr
          else
            commented_on=issue
          fi
          echo "::set-output name=commented_on::$commented_on"

  # creates backport issue if commented on issue, or
  # creates backport PR if commented on PR
  # eg /backport v21.11.x
  type-branch:
    needs: backport-type
    runs-on: ubuntu-latest
    env:
      TARGET_ORG: ${{ github.event.client_payload.slash_command.args.named.org }}
      TARGET_REPO: ${{ github.event.client_payload.slash_command.args.named.repo }}
    steps:
      - name: Get assignees
        env:
          ASSIGNEES: ${{ toJson(github.event.client_payload.github.payload.issue.assignees) }}
        id: assignees
        run: echo ::set-output name=assignees::$(echo "$ASSIGNEES" | jq -r '.[].login' | paste -s -d ',' -)

      - name: Get branch
        env:
          GITHUB_TOKEN: ${{ secrets.ACTIONS_BOT_TOKEN }}
          BRANCH: ${{ github.event.client_payload.slash_command.args.unnamed.arg1 }}
        id: branch
        run: |
          branches=$(gh api "/repos/${TARGET_ORG}/${TARGET_REPO}/branches" --jq .[].name | grep "$BRANCH")
          if [[ $branches == "" ]]; then
            exit 2
          fi
          echo ::set-output name=branch::"$BRANCH"

      - name: Discover and create milestone
        env:
          GITHUB_TOKEN: ${{ secrets.ACTIONS_BOT_TOKEN }}
          BACKPORT_BRANCH: ${{ steps.branch.outputs.branch }}
          TARGET_MILESTONE: ${{ github.event.client_payload.slash_command.args.named.milestone }}
        id: milestone
        run: |
          if [[ "${TARGET_MILESTONE}" == "auto" ]]; then
            major=$(echo "${BACKPORT_BRANCH}" | grep -Eo '^(v[0-9][0-9].[0-9][0-9])')
            latest_released=$(gh api "repos/redpanda-data/redpanda/releases" --jq '.[] | select(.draft==false).name'  | grep "${major}" | head -1)
            # latest_released=$(gh api "repos/${TARGET_ORG}/${TARGET_REPO}/releases" --jq '.[] | select(.draft==false).name'  | grep "${major}" | head -1)
            assigne_milestone=$(echo ${latest_released} | awk -F. -v OFS=. '{$NF += 1 ; print}')
          else
            assigne_milestone="${TARGET_MILESTONE}"
          fi
          if [[ $(gh api "repos/${TARGET_ORG}/${TARGET_REPO}/milestones" --jq .[].title | grep "${assigne_milestone}") == "" ]]; then
            # the below fails of something goes wrong
            gh api "repos/${TARGET_ORG}/${TARGET_REPO}/milestones" --silent --method POST -f title="${assigne_milestone}"
            sleep 20 # wait for milestone creation to be propagated
          fi
          echo ::set-output name=milestone::${assigne_milestone}

      - name: Create issue
        if: needs.backport-type.outputs.commented_on == 'issue'
        env:
          GITHUB_TOKEN: ${{ secrets.ACTIONS_BOT_TOKEN }}
          TARGET_MILESTONE: ${{ steps.milestone.outputs.milestone }}
          BACKPORT_BRANCH: ${{ steps.branch.outputs.branch }}
          ORIG_TITLE: ${{ github.event.client_payload.github.payload.issue.title }}
          ORIG_ASSIGNEES: ${{ steps.assignees.outputs.assignees }}
          ORIG_ISSUE_URL: ${{ github.event.client_payload.github.payload.issue.html_url }}
        run: |
          # assumption label "kind/backport" exists
          backport_issue_url=$(gh issue list --repo "${TARGET_ORG}/${TARGET_REPO}" \
              --state open \
              --search "[${BACKPORT_BRANCH}] ${ORIG_TITLE} in:title" \
              --json url \
              --milestone "${TARGET_MILESTONE}" \
              --jq '.[0].url')
          if [[ "$backport_issue_url" == "" ]]; then
            gh issue create --title "[${BACKPORT_BRANCH}] ${ORIG_TITLE}" \
              --label "kind/backport" \
              --repo "${TARGET_ORG}/${TARGET_REPO}" \
              --assignee "${ORIG_ASSIGNEES}" \
              --milestone "${TARGET_MILESTONE}" \
              --body "Backport ${ORIG_ISSUE_URL} to branch ${BACKPORT_BRANCH}"
          else
            gh issue comment "$ORIG_ISSUE_URL" --body "Backport issue already exists: $backport_issue_url"
          fi

      - name: Get reviewers of PR
        if: needs.backport-type.outputs.commented_on == 'pr'
        env:
          REVIEWERS: ${{ toJson(github.event.client_payload.pull_request.requested_reviewers) }}
        id: reviewers
        run: echo ::set-output name=reviewers::$(echo "$REVIEWERS" | jq -r '.[].login' | paste -s -d ',' -)

      - name: Get commits of PR
        if: needs.backport-type.outputs.commented_on == 'pr'
        env: 
          BACKPORT_PR_NUMBER: ${{ github.event.client_payload.pull_request.number }}
          GITHUB_TOKEN: ${{ secrets.ACTIONS_BOT_TOKEN }}
        id: backport_commits
        run: |
          backport_commits=$(gh api "repos/$TARGET_ORG/$TARGET_REPO/pulls/$BACKPORT_PR_NUMBER/commits" --jq .[].sha | paste -s -d ' ' -)
          echo ::set-output name=backport_commits::$backport_commits

      - uses: actions/checkout@v3
        if: needs.backport-type.outputs.commented_on == 'pr'
        with:
          repository: siretsuog/gh-slash-cmd-test
          token: ${{ secrets.ACTIONS_BOT_TOKEN }}

      - name: Backport commits and get details
        if: needs.backport-type.outputs.commented_on == 'pr'
        env:
          PR_NUMBER: ${{ github.event.client_payload.pull_request.number }}
          GITHUB_TOKEN: ${{ secrets.ACTIONS_BOT_TOKEN }}
          BACKPORT_BRANCH: ${{ steps.branch.outputs.branch }}
          ORIG_TITLE: ${{ github.event.client_payload.github.payload.issue.title }}
          BACKPORT_COMMITS: ${{ steps.backport_commits.outputs.backport_commits }}
          IS_MERGED: ${{ github.event.client_payload.pull_request.merged }}
        id: pr_details
        run: |
          if [[ "$IS_MERGED" != true ]]; then
            msg="The pull request is not merged yet. Cancelling..."
            echo "$msg"
            gh pr comment "$PR_NUMBER" \
              --body "$msg" \
              --repo "$TARGET_ORG/$TARGET_REPO"
            exit 1
          fi
          fixing_issue_urls=$(gh api graphql -f query='{
              resource(url: "https://github.com/'${TARGET_ORG}'/'${TARGET_REPO}'/pull/'${PR_NUMBER}'") {
                ... on PullRequest {
                  closingIssuesReferences(first: 20) {
                    nodes {
                      url
                    }
                  }
                }
              }
            }' --jq .data.resource.closingIssuesReferences.nodes.[].url)
          # ensure unique branch
          suffix=$(echo $(($RANDOM % 1000)))
          # git config --global user.email "vbot@vectorized.io"
          # git config --global user.name "vbotbuildovich"
          git config --global user.email "solon_gousteris@outlook.com.gr"
          git config --global user.name "siretsuog"
          git remote add upstream "https://github.com/$TARGET_ORG/$TARGET_REPO.git"
          git fetch --all
          # git remote set-url origin "https://vbotbuildovich:$GITHUB_TOKEN@github.com/vbotbuildovich/$TARGET_REPO.git"
          git remote set-url origin "https://siretsuog:$GITHUB_TOKEN@github.com/siretsuog/$TARGET_REPO.git"
          head_branch=$(echo "backport-$ORIG_TITLE-to-$BACKPORT_BRANCH-$suffix" | sed 's/ /-/g' | tr -d '[]')
          git checkout -b $head_branch remotes/upstream/$BACKPORT_BRANCH
          git cherry-pick -x $BACKPORT_COMMITS
          git push --set-upstream origin $head_branch
          git remote rm upstream
          # assumption already forked repo on bot account
          echo ::set-output name=head_branch::$head_branch
          echo ::set-output name=fixing_issue_urls::$fixing_issue_urls

      - name: Create pull request
        if: needs.backport-type.outputs.commented_on == 'pr'
        env:
          GITHUB_TOKEN: ${{ secrets.ACTIONS_BOT_TOKEN }}
          TARGET_MILESTONE: ${{ steps.milestone.outputs.milestone }}
          BACKPORT_BRANCH: ${{ steps.branch.outputs.branch }}
          ORIG_TITLE: ${{ github.event.client_payload.github.payload.issue.title }}
          ORIG_REVIEWERS: ${{ steps.reviewers.outputs.reviewers }}
          ORIG_ISSUE_URL: ${{ github.event.client_payload.github.payload.issue.html_url }}
          HEAD_BRANCH: ${{ steps.pr_details.outputs.head_branch }}
          FIXING_ISSUE_URLs: ${{ steps.pr_details.outputs.fixing_issue_urls }}
          ORIG_PR_NUMBER: ${{ github.event.client_payload.pull_request.number }}
          ORIG_PR_URL: ${{ github.event.client_payload.pull_request.html_url }}
        run: |
          set -x
          backport_issue_urls=()
          if [[ "$FIXING_ISSUE_URLs" != "" ]]; then
            for FIXING_ISSUE_URL in $FIXING_ISSUE_URLs; do
              orig_issue_number=$(echo "$FIXING_ISSUE_URL" | awk -F/ '{print $NF}')
              orig_org=$(echo "$FIXING_ISSUE_URL" | awk -F/ '{print $4}')
              orig_repo=$(echo "$FIXING_ISSUE_URL" | awk -F/ '{print $5}')

              # assumption all linked issues of original PR are in the same repo as the PR
              if [[ "$orig_repo" != "${TARGET_REPO}" || "$orig_org" != "${TARGET_ORG}" ]]; then
                break
              fi

              orig_issue_title=$(gh issue view "$orig_issue_number" \
                --repo "${orig_org}/${orig_repo}" \
                --json title --jq .title)

              backport_issue_url=$(gh issue list --repo "${orig_org}/${orig_repo}" \
                --state open \
                --search "[${BACKPORT_BRANCH}] ${orig_issue_title} in:title" \
                --json url \
                --milestone "${TARGET_MILESTONE}" \
                --jq '.[0].url')

              if [[ "$backport_issue_url" == "" ]]; then
                # backport issue does not exist and will be created
                # get orig issue assignees
                orig_issue_assingees=$(gh issue view "$orig_issue_number" \
                  --repo "${orig_org}/${orig_repo}" \
                  --json assignees --jq .assignees.[].login | paste -s -d ',' -)
                # create issue
                backport_issue_url=$(gh issue create --title "[${BACKPORT_BRANCH}] ${orig_issue_title}" \
                  --label "kind/backport" \
                  --repo "${orig_org}/${orig_repo}" \
                  --assignee "${orig_issue_assingees}" \
                  --milestone "${TARGET_MILESTONE}" \
                  --body "Backport ${FIXING_ISSUE_URL} to branch ${BACKPORT_BRANCH}. Requested by PR $ORIG_PR_URL")
              fi
              backport_issue_urls+=$(echo "Fixes $backport_issue_url, ")
            done
          fi
          # assumption label "kind/backport" exists
          gh pr create --title "[${BACKPORT_BRANCH}] ${ORIG_TITLE}" \
            --base "${BACKPORT_BRANCH}" \
            --label "kind/backport" \
            --head "siretsuog:${HEAD_BRANCH}" \
            --draft \
            --repo "${TARGET_ORG}/${TARGET_REPO}" \
            --reviewer "${ORIG_REVIEWERS}" \
            --milestone "${TARGET_MILESTONE}" \
            --body """Backport from pull request: ${ORIG_ISSUE_URL}
            $backport_issue_urls
            """

      - name: Add reaction
        uses: peter-evans/create-or-update-comment@v1
        with:
          token: ${{ secrets.ACTIONS_BOT_TOKEN }}
          repository: ${{ github.event.client_payload.github.payload.repository.full_name }}
          comment-id: ${{ github.event.client_payload.github.payload.comment.id }}
          reaction-type: hooray
